# ç”µå®¹è§¦æ‘¸ä¼ æ„Ÿå™¨æ¨¡å— - GD32C2x1ç‰ˆæœ¬

## ğŸ“ æ¦‚è¿°

æœ¬æ¨¡å—æ˜¯ä»STM32é¡¹ç›®ç§»æ¤åˆ°GD32C2x1å¹³å°çš„ç”µå®¹è§¦æ‘¸ä¼ æ„Ÿå™¨é©±åŠ¨ç¨‹åºã€‚é€šè¿‡å®šæ—¶å™¨è¾“å…¥æ•è·åŠŸèƒ½æµ‹é‡ç”µå®¹å……ç”µæ—¶é—´ï¼Œå®ç°6é€šé“è§¦æ‘¸æ£€æµ‹ã€‚

## ğŸ” åŸç†è¯´æ˜

### ç”µå®¹è§¦æ‘¸æ£€æµ‹åŸç†

ç”µå®¹è§¦æ‘¸ä¼ æ„Ÿå™¨é€šè¿‡æµ‹é‡è§¦æ‘¸æ¿ç”µå®¹çš„å……ç”µæ—¶é—´æ¥æ£€æµ‹è§¦æ‘¸äº‹ä»¶:

1. **æ”¾ç”µé˜¶æ®µ**: GPIOé…ç½®ä¸ºè¾“å‡ºæ¨¡å¼ï¼Œè¾“å‡ºä½ç”µå¹³ï¼Œä½¿è§¦æ‘¸æ¿ç”µå®¹å®Œå…¨æ”¾ç”µ
2. **å……ç”µé˜¶æ®µ**: GPIOåˆ‡æ¢ä¸ºå®šæ—¶å™¨è¾“å…¥æ•è·æ¨¡å¼ï¼Œé€šè¿‡å†…éƒ¨ä¸Šæ‹‰ç”µé˜»ç»™ç”µå®¹å……ç”µ
3. **æ•è·é˜¶æ®µ**: å®šæ—¶å™¨æµ‹é‡ç”µå®¹ä»ä½ç”µå¹³å……ç”µåˆ°é«˜ç”µå¹³é˜ˆå€¼çš„æ—¶é—´
4. **è§¦æ‘¸æ£€æµ‹**: å½“æ‰‹æŒ‡è§¦æ‘¸æ—¶ï¼Œç”µå®¹å¢å¤§ï¼Œå……ç”µæ—¶é—´å˜é•¿ï¼Œé€šè¿‡é˜ˆå€¼åˆ¤æ–­è§¦æ‘¸çŠ¶æ€

```
æ— è§¦æ‘¸æ—¶: å°ç”µå®¹ â†’ å……ç”µå¿« â†’ çŸ­æ—¶é—´åˆ°è¾¾é«˜ç”µå¹³ â†’ æ•è·å€¼å°
æœ‰è§¦æ‘¸æ—¶: å¤§ç”µå®¹ â†’ å……ç”µæ…¢ â†’ é•¿æ—¶é—´åˆ°è¾¾é«˜ç”µå¹³ â†’ æ•è·å€¼å¤§
```

### å·¥ä½œæµç¨‹

```
[åˆå§‹åŒ–] â†’ [æ”¾ç”µ] â†’ [å¯åŠ¨æ•è·] â†’ [ç­‰å¾…ä¸­æ–­]
                         â†“
              [æ•è·å®Œæˆ] â† â†
                   â†“
              [ä¸‹ä¸€é€šé“] â†’ [å¾ªç¯6ä¸ªé€šé“]
                   â†“
            [æ•°æ®å°±ç»ªå›è°ƒ] + [å†™å…¥FIFO]
```

## ğŸ“Œ ç¡¬ä»¶è¿æ¥

### å¼•è„šåˆ†é…

| é€šé“ | GPIOå¼•è„š | å®šæ—¶å™¨ | å®šæ—¶å™¨é€šé“ | å¤ç”¨åŠŸèƒ½ |
|------|---------|--------|-----------|---------|
| CH0  | PB4     | TIMER2 | CH0       | AF1     |
| CH1  | PB5     | TIMER2 | CH1       | AF1     |
| CH2  | PB0     | TIMER2 | CH2       | AF1     |
| CH3  | PB1     | TIMER2 | CH3       | AF1     |
| CH4  | PA8     | TIMER0 | CH0       | AF2     |
| CH5  | PA9     | TIMER0 | CH1       | AF2     |

### è§¦æ‘¸æ¿è®¾è®¡å»ºè®®

1. **è§¦æ‘¸æ¿å°ºå¯¸**: å»ºè®®10mm x 10mm ä»¥ä¸Š
2. **PCBææ–™**: FR4æ ‡å‡†PCBï¼Œè§¦æ‘¸åŒºåŸŸé“œç®”é¢ç§¯å°½é‡å¤§
3. **ä¸Šå±‚è¦†ç›–**: å¯åœ¨PCBä¸Šè¦†ç›–1-3mmåšçš„éå¯¼ç”µææ–™(å¡‘æ–™/ç»ç’ƒ)
4. **åœ°å¹³é¢**: è§¦æ‘¸æ¿ä¸‹æ–¹å»ºè®®é“ºåœ°ï¼Œä½œä¸ºå±è”½å±‚
5. **èµ°çº¿**: ä»MCUåˆ°è§¦æ‘¸æ¿çš„èµ°çº¿å°½é‡çŸ­ä¸”è¿œç¦»å¹²æ‰°æº

### ç”µè·¯è¿æ¥

```
MCU GPIO â”€â”€â”€â”€â”€â”€ è§¦æ‘¸æ¿é“œç®” â”€â”€â”€â”€â”¬â”€â”€â”€â”€ (è¦†ç›–å±‚)
                              â”‚
                           æ‰‹æŒ‡è§¦æ‘¸
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. åŒ…å«å¤´æ–‡ä»¶

```c
#include "cap_touch.h"
```

### 2. åˆå§‹åŒ–æ¨¡å—

```c
cap_touch_init();
```

### 3. æ³¨å†Œå›è°ƒå‡½æ•°(å¯é€‰)

```c
void on_touch_ready(capture_data_t *data) {
    // æ•°æ®é‡‡é›†å®Œæˆæ—¶çš„å¤„ç†
    printf("CH0: %lu\n", data->values[0]);
}

cap_touch_register_data_ready_callback(on_touch_ready);
```

### 4. ä¸»å¾ªç¯ä¸­è°ƒç”¨å¤„ç†å‡½æ•°

```c
while(1) {
    cap_touch_process();  // çŠ¶æ€æœºå¤„ç†
    
    // å…¶ä»–ä»£ç ...
}
```

### 5. è¯»å–è§¦æ‘¸æ•°æ®

#### æ–¹æ³•1: ç›´æ¥è¯»å–

```c
uint32_t value = cap_touch_get_value(0);  // è¯»å–é€šé“0
```

#### æ–¹æ³•2: è¯»å–æ•°ç»„

```c
uint32_t *values = cap_touch_get_values_array();
for(int i = 0; i < 6; i++) {
    printf("CH%d: %lu\n", i, values[i]);
}
```

#### æ–¹æ³•3: ä»FIFOè¯»å–

```c
capture_data_t data;
if(cap_touch_fifo_read(&data) == CAP_OK) {
    // å¤„ç†æ•°æ®
    printf("Timestamp: %llu\n", data.timestamp);
}
```

## ğŸ“Š æ•°æ®ç»“æ„

### capture_data_t

```c
typedef struct {
    uint32_t values[6];  // 6ä¸ªé€šé“çš„æ•è·å€¼
    uint64_t timestamp;  // æ—¶é—´æˆ³(å¾®ç§’)
} capture_data_t;
```

## ğŸ”§ APIæ¥å£

### åˆå§‹åŒ–ä¸æ§åˆ¶

| å‡½æ•° | è¯´æ˜ |
|------|------|
| `cap_touch_init()` | åˆå§‹åŒ–è§¦æ‘¸æ¨¡å— |
| `cap_touch_process()` | çŠ¶æ€æœºå¤„ç†(ä¸»å¾ªç¯è°ƒç”¨) |

### æ•°æ®è¯»å–

| å‡½æ•° | è¯´æ˜ |
|------|------|
| `cap_touch_get_value(channel)` | è·å–æŒ‡å®šé€šé“å€¼ |
| `cap_touch_get_values_array()` | è·å–å€¼æ•°ç»„æŒ‡é’ˆ |
| `cap_touch_get_data_packet()` | è·å–å®Œæ•´æ•°æ®åŒ…æŒ‡é’ˆ |

### å›è°ƒä¸FIFO

| å‡½æ•° | è¯´æ˜ |
|------|------|
| `cap_touch_register_data_ready_callback()` | æ³¨å†Œæ•°æ®å°±ç»ªå›è°ƒ |
| `cap_touch_fifo_read()` | ä»FIFOè¯»å–æ•°æ® |
| `cap_touch_fifo_get_count()` | è·å–FIFOæ•°æ®åŒ…æ•°é‡ |
| `cap_touch_fifo_clear()` | æ¸…ç©ºFIFO |

## âš™ï¸ é…ç½®è¯´æ˜

### å®šæ—¶å™¨é…ç½®

```c
prescaler = 47;       // é¢„åˆ†é¢‘å™¨: 48MHz / 48 = 1MHz
period = 0xFFFF;      // å‘¨æœŸ: 65535
```

å®šæ—¶å™¨è®¡æ•°é¢‘ç‡ä¸º1MHzï¼Œæ¯ä¸ªè®¡æ•°å•ä½ä»£è¡¨1å¾®ç§’ã€‚

### é˜ˆå€¼è°ƒæ•´

æ ¹æ®å®é™…ç¡¬ä»¶è°ƒæ•´è§¦æ‘¸é˜ˆå€¼:

```c
#define TOUCH_THRESHOLD 10000  // è§¦æ‘¸é˜ˆå€¼

if(value < TOUCH_THRESHOLD) {
    // æ£€æµ‹åˆ°è§¦æ‘¸
}
```

å»ºè®®å…ˆæµ‹é‡æ— è§¦æ‘¸æ—¶çš„åŸºå‡†å€¼ï¼Œç„¶åè®¾ç½®é˜ˆå€¼ä¸ºåŸºå‡†å€¼çš„50%-80%ã€‚

### æ‰«æé€Ÿåº¦è°ƒæ•´

```c
#define DISCHARGE_CYCLES 2  // æ”¾ç”µå‘¨æœŸæ•°
```

å¢åŠ æ­¤å€¼å¯ä»¥ç¡®ä¿æ›´å……åˆ†çš„æ”¾ç”µï¼Œä½†ä¼šé™ä½æ‰«æé€Ÿåº¦ã€‚

## ğŸ”¬ è°ƒè¯•æŠ€å·§

### 1. ä¸²å£è¾“å‡ºæµ‹è¯•

```c
printf("CH0:%lu CH1:%lu CH2:%lu CH3:%lu CH4:%lu CH5:%lu\n",
       cap_touch_get_value(0), cap_touch_get_value(1),
       cap_touch_get_value(2), cap_touch_get_value(3),
       cap_touch_get_value(4), cap_touch_get_value(5));
```

### 2. åŸºå‡†å€¼æµ‹é‡

æ— è§¦æ‘¸çŠ¶æ€ä¸‹è¿è¡Œç¨‹åºï¼Œè®°å½•å„é€šé“çš„å¹³å‡å€¼ä½œä¸ºåŸºå‡†:

```
CH0: 5000-8000  (æ­£å¸¸èŒƒå›´)
CH1: 5000-8000
...
```

### 3. è§¦æ‘¸æµ‹è¯•

ç”¨æ‰‹æŒ‡è§¦æ‘¸å„ä¸ªè§¦æ‘¸æ¿ï¼Œè§‚å¯Ÿå€¼çš„å˜åŒ–:

```
æ— è§¦æ‘¸: 6000
æœ‰è§¦æ‘¸: 12000  (çº¦ä¸º2å€)
```

### 4. å¸¸è§é—®é¢˜

| é—®é¢˜ | åŸå›  | è§£å†³æ–¹æ³• |
|------|------|---------|
| æ‰€æœ‰é€šé“å€¼ä¸º65535 | æ²¡æœ‰ä¸Šæ‹‰ç”µé˜»æˆ–ç”µå®¹å¤ªå° | æ£€æŸ¥ç¡¬ä»¶ï¼Œç¡®ä¿GPIOæœ‰ä¸Šæ‹‰ |
| å€¼ä¸ç¨³å®šæ³¢åŠ¨å¤§ | å¹²æ‰°å¤§æˆ–èµ°çº¿å¤ªé•¿ | å¢åŠ æ»¤æ³¢ï¼Œç¼©çŸ­èµ°çº¿ |
| æ— æ³•åŒºåˆ†è§¦æ‘¸ | ç”µå®¹å¤ªå°æˆ–é˜ˆå€¼ä¸å¯¹ | å¢å¤§è§¦æ‘¸æ¿é¢ç§¯ï¼Œè°ƒæ•´é˜ˆå€¼ |
| å“åº”æ…¢ | æ‰«æé€Ÿåº¦æ…¢ | å‡å°‘DISCHARGE_CYCLES |

## ğŸ“ ç§»æ¤è¯´æ˜

### ä»STM32åˆ°GD32çš„ä¸»è¦ä¿®æ”¹

1. **HALåº“æ›¿æ¢ä¸ºæ ‡å‡†å¤–è®¾åº“**
   - `HAL_GPIO_xxx` â†’ `gpio_xxx`
   - `HAL_TIM_xxx` â†’ `timer_xxx`

2. **GPIOé…ç½®æ–¹å¼**
   - STM32: `GPIO_InitTypeDef`ç»“æ„ä½“
   - GD32: `gpio_mode_set()` + `gpio_af_set()`

3. **å®šæ—¶å™¨é…ç½®**
   - STM32: `TIM_HandleTypeDef`
   - GD32: `timer_parameter_struct` + ç›´æ¥å¯„å­˜å™¨æ“ä½œ

4. **ä¸­æ–­å¤„ç†**
   - STM32: HALå›è°ƒå‡½æ•°è‡ªåŠ¨è°ƒç”¨
   - GD32: éœ€è¦æ‰‹åŠ¨åœ¨ä¸­æ–­å¤„ç†å‡½æ•°ä¸­è°ƒç”¨

5. **ç±»å‹å®šä¹‰**
   - ç§»é™¤äº†å¯¹`dl_types.h`çš„ä¾èµ–
   - ä½¿ç”¨è‡ªå®šä¹‰çš„`cap_err_t`å’Œ`cap_bool_t`

6. **FIFOå®ç°**
   - ç§»é™¤äº†å¯¹`dl_fifo.h`çš„ä¾èµ–
   - å®ç°äº†ç®€æ˜“çš„ç¯å½¢FIFO

## ğŸ“„ è®¸å¯è¯

æœ¬ä»£ç åŸºäºåŸSTM32é¡¹ç›®ç§»æ¤ï¼Œéµå¾ªåŸé¡¹ç›®çš„è®¸å¯è¯ã€‚

## ğŸ‘¨â€ğŸ’» ä½œè€…

ç§»æ¤è€…: AI Assistant
ç§»æ¤æ—¥æœŸ: 2025-11-01
åŸå§‹ä»£ç æ¥æº: STM32F405é¡¹ç›®

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰é—®é¢˜ï¼Œè¯·æ£€æŸ¥:
1. ç¡¬ä»¶è¿æ¥æ˜¯å¦æ­£ç¡®
2. å¼•è„šé…ç½®æ˜¯å¦ä¸å®é™…ç¡¬ä»¶ä¸€è‡´
3. æ—¶é’Ÿé…ç½®æ˜¯å¦æ­£ç¡®(é»˜è®¤48MHz)
4. ä¸­æ–­ä¼˜å…ˆçº§è®¾ç½®
