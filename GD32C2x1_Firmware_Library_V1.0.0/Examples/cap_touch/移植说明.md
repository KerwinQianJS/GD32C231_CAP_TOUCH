# 电容触摸传感器移植说明

## 📋 功能分析总结

### 原STM32代码功能

您提供的`cap_touch.c`和`cap_touch.h`是一个**电容式触摸传感器驱动模块**，主要功能如下:

#### 1. **核心原理**
- 使用RC充电原理检测电容值变化
- 通过定时器输入捕获测量电容充电时间
- 充电时间 ∝ 电容值，手指触摸会增大电容

#### 2. **工作流程**
```
放电阶段 (GPIO输出低) 
    ↓
充电阶段 (GPIO→定时器输入捕获模式)
    ↓
定时器捕获 (测量充电到高电平的时间)
    ↓
读取捕获值 (时间值代表电容大小)
    ↓
循环扫描6个通道
```

#### 3. **状态机设计**
```c
CAP_STATE_INIT          // 初始化，配置GPIO为输出
    ↓
CAP_STATE_DISCHARGE     // 放电，等待足够的放电时间
    ↓
CAP_STATE_WAIT_CAPTURE  // 等待捕获，GPIO切换为定时器输入
    ↓
捕获中断触发 → 读取值 → 下一通道
```

#### 4. **多通道管理**
- 支持6个触摸通道
- 循环扫描，非阻塞式处理
- 使用不同的定时器通道(TIM2/TIM3/TIM4/TIM9)

#### 5. **数据管理**
- FIFO缓存: 4KB环形缓冲区
- 回调通知: 数据采集完成时调用
- 时间戳: 记录每组数据的采集时间

#### 6. **中断处理**
- 输入捕获中断: 捕获充电完成时间点
- 周期中断(可选): 定期触发采集

---

## 🔄 移植到GD32的主要修改

### 1. **HAL库 → 标准外设库**

| STM32 HAL | GD32 标准库 |
|-----------|------------|
| `HAL_GPIO_Init()` | `gpio_mode_set()` + `gpio_af_set()` |
| `HAL_GPIO_WritePin()` | `gpio_bit_write()` |
| `HAL_TIM_IC_Start_IT()` | `timer_interrupt_enable()` + `timer_enable()` |
| `HAL_TIM_ReadCapturedValue()` | `timer_channel_capture_value_register_read()` |
| `HAL_TIM_RegisterCallback()` | 手动在中断函数中调用 |

### 2. **GPIO配置方式**

**STM32:**
```c
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
```

**GD32:**
```c
gpio_mode_set(GPIOE, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_5);
gpio_output_options_set(GPIOE, GPIO_OTYPE_PP, GPIO_OSPEED_LEVEL_1, GPIO_PIN_5);
gpio_af_set(GPIOE, GPIO_AF_3, GPIO_PIN_5);
```

### 3. **定时器配置**

**STM32:**
```c
extern TIM_HandleTypeDef htim3;
HAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_3);
```

**GD32:**
```c
timer_parameter_struct timer_initpara;
timer_initpara.prescaler = 47;
timer_initpara.period = 65535;
timer_init(TIMER2, &timer_initpara);

timer_ic_parameter_struct timer_icinitpara;
timer_icinitpara.icpolarity = TIMER_IC_POLARITY_RISING;
timer_input_capture_config(TIMER2, TIMER_CH_0, &timer_icinitpara);
```

### 4. **中断处理**

**STM32:**
```c
void cap_touch_timer_capture_callback(TIM_HandleTypeDef *htim)
{
    // HAL自动调用
}
```

**GD32:**
```c
void TIMER2_IRQHandler(void)
{
    if (SET == timer_interrupt_flag_get(TIMER2, TIMER_INT_FLAG_CH0)) {
        timer_interrupt_flag_clear(TIMER2, TIMER_INT_FLAG_CH0);
        cap_touch_timer_capture_callback(TIMER2, TIMER_CH_0);
    }
}
```

### 5. **类型定义适配**

移除STM32特有的依赖:
```c
// 移除
#include "stm32f4xx_hal.h"
#include "dl_types.h"
#include "dl_fifo.h"

// 替换为
#include "gd32c2x1.h"
typedef enum { CAP_OK = 0, CAP_ERROR = 1 } cap_err_t;
```

### 6. **FIFO实现**

STM32版本使用了外部的`dl_fifo`库，GD32版本实现了简化的环形FIFO:

```c
typedef struct {
    uint8_t  *buffer;
    uint16_t  size;
    uint16_t  head;
    uint16_t  tail;
    uint16_t  count;
} simple_fifo_t;
```

---

## 🎯 使用建议

### 1. **硬件设计**

触摸板PCB设计:
```
┌──────────────────┐
│   覆盖层(1-3mm)   │  ← 塑料/玻璃
├──────────────────┤
│   触摸铜箔区域    │  ← 10mm x 10mm以上
├──────────────────┤
│   地平面(屏蔽)    │
└──────────────────┘
```

### 2. **阈值校准**

```c
// 步骤1: 测量无触摸基准值
uint32_t baseline[6];
for(int i = 0; i < 6; i++) {
    baseline[i] = cap_touch_get_value(i);
}

// 步骤2: 设置阈值(基准值的50%-80%)
#define TOUCH_THRESHOLD_RATIO 0.7

// 步骤3: 检测触摸
for(int i = 0; i < 6; i++) {
    uint32_t current = cap_touch_get_value(i);
    if(current < baseline[i] * TOUCH_THRESHOLD_RATIO) {
        // 检测到触摸
    }
}
```

### 3. **性能优化**

```c
// 调整扫描速度
#define DISCHARGE_CYCLES 2  // 减小可提高扫描速度

// 主循环优化
while(1) {
    cap_touch_process();  // 不延时，全速扫描
    
    // 每完成一轮6通道后处理
    if(g_current_channel == 0) {
        // 处理触摸事件
    }
}
```

### 4. **调试技巧**

```c
// 串口输出原始值
void on_touch_ready(capture_data_t *data) {
    printf("RAW: %lu %lu %lu %lu %lu %lu\n",
           data->values[0], data->values[1], data->values[2],
           data->values[3], data->values[4], data->values[5]);
}

// 观察值的变化范围
// 正常: 5000-10000
// 触摸: 10000-20000
// 异常: 65535(超时)
```

---

## ⚠️ 注意事项

### 1. **引脚冲突**
- PA8/PA9默认配置为TIMER0，如果用于其他功能请修改
- 确保引脚未被其他外设占用

### 2. **时钟配置**
- 代码假设系统时钟为48MHz
- 如果时钟不同，需调整预分频器: `prescaler = (SystemCoreClock / 1000000) - 1`

### 3. **中断优先级**
- 触摸中断优先级设置为2
- 如果系统有更高优先级的中断，请调整

### 4. **上拉电阻**
- GPIO内部上拉约40kΩ
- 如果充电太慢，可外接10kΩ上拉电阻

### 5. **干扰处理**
- 触摸板远离高频信号源
- 走线尽量短且粗
- 可增加软件滤波:

```c
// 简单滤波
#define FILTER_SIZE 4
uint32_t filter_buffer[6][FILTER_SIZE];
uint8_t filter_index = 0;

uint32_t get_filtered_value(uint8_t ch) {
    uint32_t sum = 0;
    for(int i = 0; i < FILTER_SIZE; i++) {
        sum += filter_buffer[ch][i];
    }
    return sum / FILTER_SIZE;
}
```

---

## 📁 文件清单

移植后的文件结构:
```
cap_touch/
├── cap_touch.h          # 触摸模块头文件
├── cap_touch.c          # 触摸模块实现
├── main.c               # 示例主程序
├── systick.h            # 系统滴答定时器头文件
├── systick.c            # 系统滴答定时器实现
└── README.md            # 使用说明文档
```

---

## 🔧 下一步工作

1. **编译测试**: 将文件添加到您的GD32工程中编译
2. **硬件连接**: 按照引脚分配连接触摸板
3. **基准测量**: 运行程序，记录无触摸时的基准值
4. **阈值调整**: 根据基准值设置合适的触摸阈值
5. **功能验证**: 触摸测试，验证6个通道是否正常

---

## 📞 常见问题

**Q: 所有通道都是65535?**
A: 检查GPIO上拉配置，确保有充电路径

**Q: 值波动很大?**
A: 增加软件滤波，检查硬件干扰

**Q: 无法区分触摸?**
A: 增大触摸板面积，降低阈值

**Q: 扫描速度慢?**
A: 减小`DISCHARGE_CYCLES`，去掉主循环延时

---

希望这个移植版本能够在您的GD32项目中顺利运行! 🎉
